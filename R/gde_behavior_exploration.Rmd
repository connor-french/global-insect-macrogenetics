---
title: "GDE behavior exploration"
author: "Connor French"
output: html_document
---

Goals:  

  * figure out behavior of GDE when correcting for sampling. Does it vary across sample sizes?  
    - short answer- lower samples mean more variation in GDE calculation
    - makes sense, given higher sample size for simulated distribution = more precise estimate of its shape
  * Gain intuition for processes leading to different values of GDE  
  * Have a coherent explanation for paper  

# Goal 1- sample size
Goal 1 strategy:  

  * Generate distributions of genetic diversity with different sample sizes and shapes
  * calculate corrected Hill 1 for each, and see if it varies across sample sizes

```{r setup}
library(tidyverse)
library(here)
library(reticulate)
library(foreach)
library(doMC)

registerDoMC(cores = 7)
use_condaenv("genetics")
source(here("R", "helper_functions.R"))
```


vector of sample sizes to work with.
from 50 to 1000 "species".
sorting from lowest to highest sample sizes to make interpretation easy.

```{r}
set.seed(430)
sample_sizes <- runif(200, min = 50, max = 1000) %>% 
  round() %>% 
  sort()
```

## Low evenness

generate beta distributions for each sample size  

```{r}
set.seed(550)
low_even <- map(sample_sizes, ~rbeta(.x, 0.2, 3)) 
```

An example distribution for low hill number  

```{r}
hist(low_even[[150]])
```

sorted bar plot for low evenness  

```{r}
barplot(sort(low_even[[150]], decreasing = TRUE))
```


calculate hill numbers for each sample size  

```{r}
low_even_hill <- map(low_even, hill_calc)
```

hill numbers are concentrated ~0.31  

```{r}
hist(unlist(low_even_hill))
```

since the sample size vector is sorted, lower indices are lower sample sizes.  
looks like there is more variation at lower sample sizes.  

```{r}
plot(unlist(low_even_hill))
```

## High evenness

Go through the same stepop_size_current as low evenness  
We also see more variaion at low sample sizes vs. higher sample sizes. Makes sense. 

```{r}
# generate beta distributions for each sample size 
hi_even <- map(sample_sizes, ~rbeta(.x, 3, 3)) 

# calculate hill numbers for each sample size
hi_even_hill <- map(hi_even, hill_calc)
```

example distribution for high hill number  

```{r}
hist(hi_even[[150]])
```

sorted bar plot. Notice how it is less dramatic of a decrease compared to a community with less even genetic diversities.  

```{r}
barplot(sort(hi_even[[150]], decreasing = TRUE))
```


```{r}
# hill numbers are concentrated ~0.925
hist(unlist(hi_even_hill))
```


```{r}
# since the sample size vector is sorted, higher indices are higher sample sizes
# looks like there is more variation at lower sample sizes
plot(unlist(hi_even_hill))
```

# Goal 2- processes

Goal 2 strategy:  

* Simulate genetic data for a community under a variety of demographic scenarios that include:  
  - stability
  - recent demographic expansion  
    - all species respond the same way  
    - some expand, some remain stable  
  - recent demographic contraction  
    - all species respond the same way  
    - some contract, some remain stable  
  - recent bottleneck
    - ""
  - recent and past bottleneck
    - ""  
* calculate pi for each species  
* calculate GDE and GDM across species  
* do this many times to generate a distribution of GDE/GDM  

I would expect high GDE for each scenario where all species respond the same way. However, I expect a slightly lower GDE for the scenarios with both an expansion and contraction- can't articulate why 100%, but if we think about the the species as loci, there would be an overall lower pi, but a proliferation of singletons, so some species would have differing pi values. I'll see what comes out in the simulations.  

```{r, simulation-basics}
# set up demographic basics
msprime <- import("msprime")

# approximately the insect "standard" rate from Brower 1994
mut_rate <- 1e-8
# used as an approximate Ne to the observed data
# took the mean pi across all cells and used:
# pi ~= theta = 4Neu 
# Ne = pi / 4u = 0.003 / (4 * 1e-8) = 75000
# rounded up to 100,000
pop_size_current <- 100000

# average # OTUs per cell = 461, rounding up to 500
num_species <- 500

# just a reasonable number to calc stats from
num_communities <- 100

# Average # individuals per OTU = 14.6, rounding up
num_ind <- 15

# using large demographic events to highlight patterns
expansion_multiplier <- 100
contraction_multiplier <- 0.01
event_time <- 10000
# bottleneck_strength <- 10000

# function to simulate demography and calculate pi for each species
sim_demography <- function(demo, mut_rate, seed, ind_sample = 15) {
  
  ts <- msprime$sim_ancestry(ind_sample, demography = demo, sequence_length = 600, random_seed = seed)
  
  mut <- msprime$sim_mutations(ts, rate = mut_rate)
  
  return(mut$diversity())
}


```

## Stable

```{r, stable, cache=TRUE}
# specify demographic parameters
stable <-  msprime$Demography()

stable$add_population(initial_size=pop_size_current)

# unique seeds for the simulation in case the exact simulation needs to be repeated
set.seed(102333)
seeds_stable <- sample(1:100000, num_species, replace = FALSE)


# use a for loop to simulate the distribution of genetic diversities of multiple communities
stable_communities <- foreach(com = 1:num_communities) %dopar% {
  map_dbl(seeds_stable, sim_demography, demo = stable, mut_rate = mut_rate)
}
```


Calculate GDE for each community  

```{r}
stable_gde <- map_dbl(stable_communities, hill_calc)

hist(stable_gde)
```

Calculate GDM for each community  

```{r}
stable_gdm <- map_dbl(stable_communities, mean) %>% sqrt()

hist(stable_gdm)
```

Example distributions of pi for some of the simulations. 

```{r}
pi_dist_stable <- bind_cols(stable_communities) %>% 
  pivot_longer(cols = everything(), 
               names_to = "sim_num", 
               values_to = "pi")

ggplot(data = pi_dist_stable, aes(x = pi, group = sim_num)) + 
  geom_density(alpha = 0.3)
```


## Expansion

```{r, expansion, cache=TRUE}
# specify demographic parameters
expansion <-  msprime$Demography()
expansion$add_population(initial_size=pop_size_current)
expansion$add_population_parameters_change(time=event_time, initial_size=pop_size_current / expansion_multiplier)

# unique seeds for the simulation in case the exact simulation needs to be repeated
set.seed(11477)
seeds_expansion <- sample.int(1e9, num_species, replace = FALSE)


# use a for loop to simulate the distribution of genetic diversities of multiple communities
expansion_communities <- foreach(com = 1:num_communities) %dopar% {
  map_dbl(seeds_expansion, sim_demography, demo = expansion, mut_rate = mut_rate)
}

```

Calculate GDE for each community  

```{r}
expansion_gde <- map_dbl(expansion_communities, hill_calc)

hist(expansion_gde)
```

Calculate GDM for each community.  

```{r}
expansion_gdm <- map_dbl(expansion_communities, mean) %>% sqrt()

hist(expansion_gdm)
```


Example distributions of pi for some of the simulations. 

```{r}
pi_dist_expansion <- bind_cols(expansion_communities) %>% 
  pivot_longer(cols = everything(), 
               names_to = "sim_num", 
               values_to = "pi")

ggplot(data = pi_dist_expansion, aes(x = pi, group = sim_num)) + 
  geom_density(alpha = 0.3)
```

## Contraction

```{r, recent-contraction, cache=TRUE}
# specify demographic parameters
contraction <-  msprime$Demography()
contraction$add_population(initial_size=pop_size_current * contraction_multiplier)

contraction$add_population_parameters_change(time=event_time, initial_size=pop_size_current)

# unique seeds for the simulation in case the exact simulation needs to be repeated
set.seed(30919)
seeds_contraction <- sample(1:100000, num_species, replace = FALSE)


# use a for loop to simulate the distribution of genetic diversities of multiple communities
contraction_communities <- foreach(com = 1:num_communities) %dopar% {
  map_dbl(seeds_contraction, sim_demography, demo = contraction, mut_rate = mut_rate)
}

```

Calculate GDE for each community  

```{r}
contraction_gde <- map_dbl(contraction_communities, hill_calc)

hist(contraction_gde)
```

Calculate GDM for each community. 

```{r}
contraction_gdm <- map_dbl(contraction_communities, mean) %>% sqrt()

hist(contraction_gdm)
```

Example distributions of pi the simulations. 

```{r}
pi_dist_contraction <- bind_cols(contraction_communities) %>% 
  pivot_longer(cols = everything(), 
               names_to = "sim_num", 
               values_to = "pi")

ggplot(data = pi_dist_contraction, aes(x = pi, group = sim_num)) + 
  geom_density(alpha = 0.3)
```


## Combo plots

### Distributions of pi

Sampled pi distributions for all demographic scenarios.  

```{r}
pi_list <- list(
  stable = pi_dist_stable,
  expansion = pi_dist_expansion,
  contraction = pi_dist_contraction
)

pi_combo <- bind_rows(pi_list,
                      .id = "demography")

```

Write raw sims to a csv

```{r, eval=FALSE}
write_csv(pi_combo, here("output", "spreadsheets", "coalescent_simulations_output.csv"))
```

```{r, echo=FALSE}
pi_combo <- read_csv(here("output", "spreadsheets", "coalescent_simulations_output.csv"))
```



### GDE and GDM
To compare the GDE and GDM distributions of all scenarios where each species responded the same.  

```{r, combo-plots}
# create a data frame for plotting
combo_gde <- tibble(
  stable = stable_gde,
  expansion = expansion_gde,
  contraction = contraction_gde
) %>% 
  pivot_longer(cols = everything(), 
               names_to = "demography",
               values_to = "gde") %>% 
  mutate(demography = fct_reorder(demography, gde))

combo_gdm <- tibble(
  stable = stable_gdm,
  expansion = expansion_gdm,
  contraction = contraction_gdm
) %>% 
  pivot_longer(cols = everything(), 
               names_to = "demography",
               values_to = "gdm") %>% 
  mutate(demography = fct_reorder(demography, gdm))


# density plot
ggplot(data = combo_gde, aes(x = gde, y = demography)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.5, height = 0.2) +
  theme_minimal()

ggplot(data = combo_gdm, aes(x = gdm, y = demography)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.5, height = 0.2) +
  theme_minimal()
```


# Other scenarios

## Bottleneck

```{r, recent-bottleneck, cache=TRUE}
# specify demographic parameters
bottleneck <-  msprime$Demography()
bottleneck$add_population(initial_size=pop_size_current)
bottleneck$add_instantaneous_bottleneck(time=event_time, strength=bottleneck_strength, population = 0L)

# unique seeds for the simulation in case the exact simulation needs to be repeated
set.seed(411417)
seeds_bottleneck <- sample(1:100000, num_species, replace = FALSE)


# use a for loop to simulate the distribution of genetic diversities of multiple communities
bottleneck_communities <- foreach(com = 1:num_communities) %dopar% {
  map_dbl(seeds_bottleneck, sim_demography, demo = bottleneck, mut_rate = mut_rate)
}

```

Calculate GDE for each community  

```{r}
bottleneck_gde <- map_dbl(bottleneck_communities, hill_calc)

hist(bottleneck_gde)
```

Calculate GDM for each community. GDM is likely higher than in the expansion scenario since the bottleneck only happened 100 generations ago and the pop size went from a historical 10000 individuals to a contemporary 5000 individuals, while the expansion went from a historical 5000 individuals to a contemporary 10000 individuals, so more genetic diversity built up in this scenario.   

```{r}
bottleneck_gdm <- map_dbl(bottleneck_communities, mean) %>% sqrt()

hist(bottleneck_gdm)
```
Example distributions of pi for some of the simulations. 

```{r}
pi_dist_bottleneck <- bind_cols(sample(bottleneck_communities, 50)) %>% 
  pivot_longer(cols = everything(), 
               names_to = "sim_num", 
               values_to = "pi")

ggplot(data = pi_dist_bottleneck, aes(x = pi, group = sim_num)) + 
  geom_density(alpha = 0.3)
```

## Two bottlenecks

```{r, two-bottleneck, cache=TRUE}
# specify demographic parameters
two_bottleneck <-  msprime$Demography()
two_bottleneck$add_population(initial_size=pop_size_current)
two_bottleneck$add_instantaneous_bottleneck(time=event_time, strength=bottleneck_strength, population = 0L)
two_bottleneck$add_instantaneous_bottleneck(time=event_time * 10, strength=bottleneck_strength, population = 0L)

# unique seeds for the simulation in case the exact simulation needs to be repeated
set.seed(14671)
seeds_two_bottleneck <- sample(1:100000, num_species, replace = FALSE)


# use a for loop to simulate the distribution of genetic diversities of multiple communities
two_bottleneck_communities <- foreach(com = 1:num_communities) %dopar% {
  map_dbl(seeds_two_bottleneck, sim_demography, demo = two_bottleneck, mut_rate = mut_rate)
}

```

Calculate GDE for each community  

```{r}
two_bottleneck_gde <- map_dbl(two_bottleneck_communities, hill_calc)

hist(two_bottleneck_gde)
```

Calculate GDM for each community. GDM is likely higher than in the expansion scenario since the two_bottleneck only happened 100 generations ago and the pop size went from a historical 10000 individuals to a contemporary 5000 individuals, while the expansion went from a historical 5000 individuals to a contemporary 10000 individuals, so more genetic diversity built up in this scenario.   

```{r}
two_bottleneck_gdm <- map_dbl(two_bottleneck_communities, mean) %>% sqrt()

hist(two_bottleneck_gdm)
```


Example distributions of pi for some of the simulations. 

```{r}
pi_dist_two_bottleneck <- bind_cols(sample(two_bottleneck_communities, 50)) %>% 
  pivot_longer(cols = everything(), 
               names_to = "sim_num", 
               values_to = "pi")

ggplot(data = pi_dist_two_bottleneck, aes(x = pi, group = sim_num)) + 
  geom_density(alpha = 0.3)
```





## Varying responses

Now I'm going to combine different demographic syndromes to simulate different responses to the environment.


### Stable + expansion

I originally was just going to sample from existing simulations, but I'm worried that will make the results artificially similar. I'm going to rerun the simulations for each demographic scenario and combine them.  

```{r, stable-expansion, eval=FALSE}
# unique seeds for the simulation in case the exact simulation needs to be repeated
set.seed(11233)
seeds_s <- sample(1:100000, num_species / 2, replace = FALSE)
set.seed(1992)
seeds_e <- sample(1:100000, num_species / 2, replace = FALSE)

# have to re-define demography
stable <-  msprime$Demography()
stable$add_population(initial_size=pop_size_current)

expansion <-  msprime$Demography()
expansion$add_population(initial_size=pop_size_current * expansion_multiplier)
expansion$add_population_parameters_change(time=event_time, initial_size=pop_size_current)


# use a for loop to simulate the distribution of genetic diversities of multiple communities
s_communities <- foreach(com = 1:num_communities) %dopar% {
  map_dbl(seeds_s, sim_demography, demo = stable, mut_rate = mut_rate)
}

e_communities <- foreach(com = 1:num_communities) %dopar% {
  map_dbl(seeds_e, sim_demography, demo = expansion, mut_rate = mut_rate)
}

# combine the simulations
se <- map2(s_communities, e_communities, c)

# calculate gde
se_gde <- map_dbl(se, hill_calc)

# calculate gdm
se_gdm <- map_dbl(se, mean) %>% 
  sqrt()
```


### Stable + contraction

```{r, stable-contraction, eval=FALSE}
# unique seeds for the simulation in case the exact simulation needs to be repeated
set.seed(1965)
seeds_s <- sample(1:100000, num_species / 2, replace = FALSE)
set.seed(1736)
seeds_c <- sample(1:100000, num_species / 2, replace = FALSE)


# have to re-define demography
stable <-  msprime$Demography()
stable$add_population(initial_size=pop_size_current)

contraction <-  msprime$Demography()
contraction$add_population(initial_size=pop_size_current * contraction_multiplier)
contraction$add_population_parameters_change(time=event_time, initial_size=pop_size_current)


# use a for loop to simulate the distribution of genetic diversities of multiple communities
s_communities <- foreach(com = 1:num_communities) %dopar% {
  map_dbl(seeds_s, sim_demography, demo = stable, mut_rate = mut_rate)
}

c_communities <- foreach(com = 1:num_communities) %dopar% {
  map_dbl(seeds_c, sim_demography, demo = contraction, mut_rate = mut_rate)
}

# combine the simulations
sc <- map2(s_communities, c_communities, c)

# calculate gde
sc_gde <- map_dbl(sc, hill_calc)

# calculate gdm
sc_gdm <- map_dbl(sc, mean) %>% 
  sqrt()
```



### Stable + bottleneck


```{r, stable-bottleneck, eval=FALSE}
# unique seeds for the simulation in case the exact simulation needs to be repeated
set.seed(3454755)
seeds_s <- sample(1:100000, num_species / 2, replace = FALSE)
set.seed(41442)
seeds_b <- sample(1:100000, num_species / 2, replace = FALSE)

# have to re-define demography
stable <-  msprime$Demography()
stable$add_population(initial_size=pop_size_current)

bottleneck <-  msprime$Demography()
bottleneck$add_population(initial_size=pop_size_current)
bottleneck$add_instantaneous_bottleneck(time=event_time, strength=bottleneck_strength, population = 0L)

# use a for loop to simulate the distribution of genetic diversities of multiple communities
s_communities <- foreach(com = 1:num_communities) %dopar% {
  map_dbl(seeds_s, sim_demography, demo = stable, mut_rate = mut_rate)
}

b_communities <- foreach(com = 1:num_communities) %dopar% {
  map_dbl(seeds_b, sim_demography, demo = bottleneck, mut_rate = mut_rate)
}

# combine the simulations
sb <- map2(s_communities, b_communities, c)

# calculate gde
sb_gde <- map_dbl(sb, hill_calc)

# calculate gdm
sb_gdm <- map_dbl(sb, mean) %>% 
  sqrt()
```

